{"version":3,"sources":["../src/utils/types.ts"],"sourcesContent":["import * as React from 'react';\n\n/**\n * Helper type that works similar to Omit,\n * but when modifying an union type it will distribute the omission to all the union members.\n *\n * See [distributive conditional types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types) for more information\n */\n// Traditional Omit is basically equivalent to => Pick<T, Exclude<keyof T, K>>\n//\n// let's say we have Omit<{ a: string } | { b: string }, 'a'>\n// equivalent to: Pick<{ a: string } | { b: string }, Exclude<keyof ({ a: string } | { b: string }), 'a'>>\n// The expected result would be {} | { b: string }, the omission of 'a' from all the union members,\n// but keyof ({ a: string } | { b: string }) is never as they don't share common keys\n// so  Exclude<never, 'a'> is never,\n// and Pick<{ a: string } | { b: string }, never> is {}.\n//\n// With DistributiveOmit on the other hand it becomes like this:\n// DistributiveOmit<{ a: string } | { b: string }, 'a'>\n// equivalent to: Omit<{ a: string }, 'a'> | Omit<{ b: string }, 'a'>\n// Since every single Omit clause in this case is being applied to a single union member there's no conflicts on keyof evaluation and in the second clause Omit<{ b: string }, 'a'> becomes { b: string },\n// so the result is {} | { b: string }, as expected.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type DistributiveOmit<T, K extends keyof any> = T extends unknown ? Omit<T, K> : T;\n\n/**\n * @public\n *\n * Helper type that works similar to Pick,\n * but when modifying an union type it will distribute the picking to all the union members.\n *\n * See {@link https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types} for more information\n */\nexport type DistributivePick<T, K> = T extends unknown ? Pick<T, K & keyof T> : never;\n\n/**\n * Converts a union type (`A | B | C`) to an intersection type (`A & B & C`)\n */\nexport type UnionToIntersection<U> = (U extends unknown ? (x: U) => U : never) extends (x: infer I) => U ? I : never;\n\n/**\n * @internal\n * If type T includes `null`, remove it and add `undefined` instead.\n */\nexport type ReplaceNullWithUndefined<T> = T extends null ? Exclude<T, null> | undefined : T;\n\n/**\n * @internal\n * With react 18, our `children` type starts leaking everywhere and that causes conflicts on component declaration, specially in the `propTypes` property of\n * both `ComponentClass` and `FunctionComponent`.\n *\n * This type substitutes `React.ComponentType` only keeping the function signature, it omits `propTypes`, `displayName` and other properties that are not\n * required for the inference.\n */\nexport type ComponentType<P = {}> = ComponentClass<P> | FunctionComponent<P>;\n\n/**\n * @internal\n *\n * On types/react 18 there are two types being delivered,\n * they rely on the typescript version to decide which will be consumed {@link https://github.com/DefinitelyTyped/DefinitelyTyped/blob/b59dc3ac1e2770fbd6cdbb90ba52abe04c168196/types/react/package.json#L10}\n *\n * If TS is higher than 5.0 then the `FunctionComponent` will be returning ReactNode (which we don't support)\n * If TS is below or equal to 5.0 then the `FunctionComponent` will be returning ReactElement | null (which we support)\n *\n * Since it's not possible to have a single type that works for both cases\n * (as ReactNode is more specific, and this will break while evaluating functions),\n * we need to create our own `FunctionComponent` type\n * that will work for both cases.\n *\n * **THIS TYPE IS INTERNAL AND SHOULD NEVER BE EXPOSED**\n */\nexport interface FunctionComponent<P> {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (props: P): any;\n  displayName?: string;\n}\n\nexport type FC<P> = FunctionComponent<P>;\n\nexport interface ExoticComponent<P> {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (props: P): any;\n  $$typeof: symbol;\n}\n\nexport interface NamedExoticComponent<P> extends ExoticComponent<P> {\n  displayName?: string;\n}\n\n/**\n * @internal\n * **THIS TYPE IS INTERNAL AND SHOULD NEVER BE EXPOSED**\n */\nexport interface ComponentClass<P = {}, S = React.ComponentState> extends React.StaticLifecycle<P, S> {\n  new (props: P): React.Component<P, S>;\n}\n\n/**\n * @internal\n *\n * on types/react 18 ReactNode becomes a more strict type, which is not compatible with our current implementation. to avoid any issues we are creating our own ReactNode type which allows anything.\n *\n * This type should only be used for inference purposes, and should never be exposed.\n *\n * **THIS TYPE IS INTERNAL AND SHOULD NEVER BE EXPOSED**\n *\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type ReactNode = any;\n\n/**\n * Removes the 'ref' prop from the given Props type, leaving unions intact (such as the discriminated union created by\n * IntrinsicSlotProps). This allows IntrinsicSlotProps to be used with React.forwardRef.\n */\nexport type PropsWithoutRef<P> = 'ref' extends keyof P ? DistributiveOmit<P, 'ref'> : P;\n\n/**\n * Removes the 'children' prop from the given Props type, leaving unions intact (such as the discriminated union created by\n * IntrinsicSlotProps). This allows IntrinsicSlotProps to be used with React.forwardRef.\n */\nexport type PropsWithoutChildren<P> = 'children' extends keyof P ? DistributiveOmit<P, 'children'> : P;\n\n/**\n * @internal\n *\n * This type is used to determine if the current version of React is 18+ or not.\n *\n * It checks if the `React.ReactNode` has `{}` it its type.\n * If it is, then it means that the current version of React is lower than 18.\n * If it is not, then it means that the current version of React is 18 or higher.\n * This is useful for ensuring compatibility with different versions of React.\n *\n * **THIS TYPE IS INTERNAL AND SHOULD NEVER BE EXPOSED**\n */\nexport type ReactVersionDependent<Modern, Legacy> = {} extends React.ReactNode ? Legacy : Modern;\n\n/**\n * Our own alias for `JSX.Element` type that is compatible with both React 17 and React 18+.\n * Use this type when annotating JSX markup in all our code in order to avoid issues between different React versions.\n *\n * Example usage:\n *\n * BAD:\n * ```tsx\n * const renderFoo = (state: FooState) = <div {...props}>Hello World</div>;\n * // infers\n * // R17:  declare const renderFoo: (state: FooState) => JSX.Element;\n * // R18+: declare const renderFoo: (state: FooState) => React.JSX.Element;\n * ```\n *\n * GOOD:\n * ```tsx\n * import type { JSXElement } from '@fluentui/react-utilities';\n * const renderFoo = (state: FooState): JSXElement = <div {...props}>Hello World</div>;\n * ```\n */\nexport type JSXElement = React.ReactElement<\n  /* eslint-disable @typescript-eslint/no-explicit-any */\n  any,\n  any\n  /* eslint-enable @typescript-eslint/no-explicit-any */\n>;\n\n/**\n * Type representing all valid JSX intrinsic element names (e.g., 'div', 'button', 'input').\n * It's derived from `React.ElementType` by excluding all custom component types (`React.ComponentType`), ensuring it only includes standard HTML and SVG elements.\n *\n * Use this type when you need to restrict a type to only valid intrinsic element names.\n *\n * @example\n * ```tsx\n * import * as React from 'react';\n * import type { JSXIntrinsicElementKeys } from '@fluentui/react-utilities';\n *\n * const createElement = (tag: JSXIntrinsicElementKeys) => React.createElement(tag, {});\n *\n * createElement('div'); // Valid\n * createElement('span'); // Valid\n * createElement('unknown'); // Error: Argument of type '\"unknown\"' is not assignable to parameter of type 'JSXIntrinsicElementKeys'.\n * ```\n *\n * This type helps ensure that only valid intrinsic elements are used in scenarios where custom components are not allowed.\n */\nexport type JSXIntrinsicElementKeys = Exclude<React.ElementType, React.ComponentType>;\n\n/**\n * Our own alias for `JSX.IntrinsicElements` type that is compatible with both React 17 and React 18+.\n * Use this type to get the intrinsic elements from React types in order to avoid issues between different React versions.\n */\nexport type JSXIntrinsicElement<Element extends JSXIntrinsicElementKeys> = React.ComponentProps<Element>;\n"],"names":[],"mappings":";;;;;iEAAuB"}