{"version":3,"sources":["../src/compose/types.ts"],"sourcesContent":["import * as React from 'react';\nimport { SLOT_CLASS_NAME_PROP_SYMBOL, SLOT_ELEMENT_TYPE_SYMBOL, SLOT_RENDER_FUNCTION_SYMBOL } from './constants';\nimport type {\n  ComponentType,\n  FunctionComponent,\n  NamedExoticComponent,\n  PropsWithoutChildren,\n  PropsWithoutRef,\n  ReactNode,\n  ReactVersionDependent,\n  ReplaceNullWithUndefined,\n  JSXIntrinsicElementKeys,\n  JSXIntrinsicElement,\n} from '../utils/types';\n\nexport type SlotRenderFunction<Props> = (Component: React.ElementType<Props>, props: Omit<Props, 'as'>) => ReactNode;\n\n/**\n * Matches any component's Slots type (such as ButtonSlots).\n *\n * This should ONLY be used in type templates as in `extends SlotPropsRecord`;\n * it shouldn't be used as a component's Slots type.\n */\nexport type SlotPropsRecord = Record<string, UnknownSlotProps | SlotShorthandValue | null | undefined>;\n\n/**\n * The shorthand value of a slot allows specifying its child\n */\nexport type SlotShorthandValue = React.ReactElement | string | number | Iterable<ReactNode> | React.ReactPortal;\n\n/**\n * Matches any slot props type.\n *\n * This should ONLY be used in type templates as in `extends UnknownSlotProps`;\n * it shouldn't be used as the type of a slot.\n */\nexport type UnknownSlotProps = Pick<React.HTMLAttributes<HTMLElement>, 'className' | 'style'> & {\n  as?: JSXIntrinsicElementKeys;\n  children?: ReactNode;\n};\n\n/**\n * Helper type for {@link Slot}. Adds shorthand types that are assignable to the slot's `children`.\n */\ntype WithSlotShorthandValue<Props> =\n  | Props\n  | ('children' extends keyof Props ? Extract<SlotShorthandValue, Props['children']> : never);\n\n/**\n * @internal\n * Helper type for {@link Slot}. Takes the props we want to support for a slot and adds the ability for `children`\n * to be a render function that takes those props.\n *\n * Notes: For React 17 and earlier, `children` can be a render function that returns a ReactNode.\n * For React 18 and later, `children` can be any value, as React.ReactNode is a more strict type and does not allow functions anymore.\n * This means that the render functions need to be asserted as `SlotRenderFunction<Props>` for React 18 and later.\n *\n * @example\n * ```tsx\n * // For React 17 and earlier:\n * <Component slot={{ children: (Component, props) => <Component {...props} /> }} />\n *\n * // For React 18 and later:\n * <Component slot={{ children: (Component, props) => <Component {...props} /> as SlotRenderFunction<SlotProps> }} />\n * ```\n */\nexport type WithSlotRenderFunction<Props> = PropsWithoutChildren<Props> & {\n  children?: 'children' extends keyof Props\n    ? ReactVersionDependent<ReactNode, Props['children'] | SlotRenderFunction<Props>>\n    : never;\n};\n\n/**\n * @internal\n */\nexport type WithoutSlotRenderFunction<Props> = Props extends unknown\n  ? 'children' extends keyof Props\n    ? Omit<Props, 'children'> & { children?: Exclude<Props['children'], Function> }\n    : Props\n  : never;\n\n/**\n * HTML element types that are not allowed to have children.\n *\n * Reference: https://developer.mozilla.org/en-US/docs/Glossary/Empty_element\n */\ntype EmptyIntrinsicElements =\n  | 'area'\n  | 'base'\n  | 'br'\n  | 'col'\n  | 'embed'\n  | 'hr'\n  | 'img'\n  | 'input'\n  | 'link'\n  | 'meta'\n  | 'param'\n  | 'source'\n  | 'track'\n  | 'wbr';\n\n/**\n * Helper type for {@link Slot}. Modifies `JSXIntrinsicElements<Type>`:\n * * Removes legacy string ref.\n * * Disallows children for empty tags like 'img'.\n */\ntype IntrinsicElementProps<Type extends JSXIntrinsicElementKeys> = Type extends EmptyIntrinsicElements\n  ? PropsWithoutChildren<React.PropsWithRef<JSXIntrinsicElement<Type>>>\n  : React.PropsWithRef<JSXIntrinsicElement<Type>>;\n\n/**\n * The props type and shorthand value for a slot. Type is either a single intrinsic element like `'div'`,\n * or a component like `typeof Button`.\n *\n * If a slot needs to support multiple intrinsic element types, use the `AlternateAs` param (see examples below).\n *\n * By default, slots can be set to `null` to prevent them from being rendered. If a slot must always be rendered,\n * wrap with `NonNullable` (see examples below).\n *\n * @example\n * ```\n * // Intrinsic element examples:\n * Slot<'div'> // Slot is always div\n * Slot<'button', 'a'> // Defaults to button, but allows as=\"a\" with anchor-specific props\n * Slot<'span', 'div' | 'pre'> // Defaults to span, but allows as=\"div\" or as=\"pre\"\n * NonNullable<Slot<'div'>> // Slot that will always be rendered (can't be set to null by the user)\n *\n * // Component examples:\n * Slot<typeof Button> // Slot is always a Button, and accepts all of Button's Props\n * NonNullable<Slot<typeof Label>> // Slot is a Label and will always be rendered (can't be set to null by the user)\n * ```\n */\nexport type Slot<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Type extends JSXIntrinsicElementKeys | ComponentType<any> | UnknownSlotProps,\n  AlternateAs extends JSXIntrinsicElementKeys = never,\n> = IsSingleton<Extract<Type, string>> extends true\n  ?\n      | WithSlotShorthandValue<\n          Type extends JSXIntrinsicElementKeys // Intrinsic elements like `div`\n            ? { as?: Type } & WithSlotRenderFunction<IntrinsicElementProps<Type>>\n            : Type extends ComponentType<infer Props> // Component types like `typeof Button`\n            ? Props extends UnknownSlotProps\n              ? Props\n              : WithSlotRenderFunction<Props>\n            : Type // Props types like `ButtonProps`\n        >\n      | (AlternateAs extends unknown\n          ? { as: AlternateAs } & WithSlotRenderFunction<IntrinsicElementProps<AlternateAs>>\n          : never)\n      | null\n  : 'Error: First parameter to Slot must not be not a union of types. See documentation of Slot type.';\n\n/**\n * Evaluates to true if the given type contains exactly one string, or false if it is a union of strings.\n *\n * ```\n * IsSingleton<'a'> // true\n * IsSingleton<'a' | 'b' | 'c'> // false\n * ```\n */\nexport type IsSingleton<T extends string> = { [K in T]: Exclude<T, K> extends never ? true : false }[T];\n\n/**\n * Helper type for inferring the type of the as prop from a Props type.\n *\n * For example:\n * ```\n * type Example<T> = T extends AsIntrinsicElement<infer As> ? As : never;\n * ```\n */\nexport type AsIntrinsicElement<As extends JSXIntrinsicElementKeys> = { as?: As };\n\n/**\n * Removes SlotShorthandValue and null from the slot type, extracting just the slot's Props object.\n */\nexport type ExtractSlotProps<S> = Exclude<S, SlotShorthandValue | null | undefined>;\n\n/**\n * Defines the Props type for a component given its slots and the definition of which one is the primary slot,\n * defaulting to root if one is not provided.\n */\nexport type ComponentProps<Slots extends SlotPropsRecord, Primary extends keyof Slots = 'root'> =\n  // Include a prop for each slot (see note below about the Omit)\n  // Note: the `Omit<Slots, Primary & 'root'>` here is a little tricky. Here's what it's doing:\n  // * If the Primary slot is 'root', then omit the `root` slot prop.\n  // * Otherwise, don't omit any props: include *both* the Primary and `root` props.\n  //   We need both props to allow the user to specify native props for either slot because the `root` slot is\n  //   special and always gets className and style props, per RFC https://github.com/microsoft/fluentui/pull/18983\n  Omit<Slots, Primary & 'root'> &\n    // Include all of the props of the primary slot inline in the component's props\n    PropsWithoutRef<ExtractSlotProps<Slots[Primary]>>;\n\n/**\n * Defines the State object of a component given its slots.\n */\nexport type ComponentState<Slots extends SlotPropsRecord> = {\n  /**\n   * @deprecated\n   * The base element type for each slot.\n   * This property is deprecated and will be removed in a future version.\n   * The slot base element type is declared through `slot.*(slotShorthand, {elementType: ElementType})` instead.\n   */\n  components: {\n    [Key in keyof Slots]-?: React.ElementType;\n  };\n} & {\n  // Include a prop for each slot, with the shorthand resolved to a props object\n  // The root slot can never be null, so also exclude null from it\n  [Key in keyof Slots]: ReplaceNullWithUndefined<\n    WithoutSlotRenderFunction<Exclude<Slots[Key], SlotShorthandValue | (Key extends 'root' ? null : never)>>\n  >;\n};\n\n/**\n * This is part of a hack to infer the element type from a native element *props* type.\n * The only place the original element is found in a native props type (at least that's workable\n * for inference) is in the event handlers, so some of the helper types use this event handler\n * name to infer the original element type.\n *\n * Notes:\n * - Using an extremely obscure event handler reduces the likelihood that its signature will be\n *   modified in any component's props.\n * - Inferring based on a single prop name instead of a larger type like `DOMAttributes<T>` should be\n *   less expensive for typescript to evaluate and is less likely to result in type expansion in .d.ts.\n */\ntype ObscureEventName = 'onLostPointerCaptureCapture';\n\n/**\n * Infers the element type from props that are declared using ComponentProps.\n */\nexport type InferredElementRefType<Props> = ObscureEventName extends keyof Props\n  ? Required<Props>[ObscureEventName] extends React.PointerEventHandler<infer Element>\n    ? Element\n    : never\n  : never;\n\n/**\n * Return type for `React.forwardRef`, including inference of the proper typing for the ref.\n *\n * @remarks\n * {@link React.RefAttributes} is {@link https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/69756 | leaking string references} into `forwardRef` components\n *  after introducing {@link https://github.com/DefinitelyTyped/DefinitelyTyped/pull/68720 | RefAttributes Type Extension}, which shipped in `@types/react@18.2.61`\n * - `forwardRef` component do not support string refs.\n * - uses custom `RefAttributes` which is compatible with all React versions enforcing no `string` allowance.\n */\nexport type ForwardRefComponent<Props> = NamedExoticComponent<Props & RefAttributes<InferredElementRefType<Props>>>;\n\n/**\n * Helper type to correctly define the slot class names object.\n */\nexport type SlotClassNames<Slots> = {\n  [SlotName in keyof Slots]-?: string;\n};\n\n/**\n * A definition of a slot, as a component, very similar to how a React component is declared,\n * but with some additional metadata that is used to determine how to render the slot.\n */\nexport type SlotComponentType<Props> = WithoutSlotRenderFunction<Props> &\n  FunctionComponent<{ children?: ReactNode }> & {\n    /**\n     * @internal\n     */\n    [SLOT_RENDER_FUNCTION_SYMBOL]?: SlotRenderFunction<Props>;\n    /**\n     * @internal\n     */\n    [SLOT_ELEMENT_TYPE_SYMBOL]:\n      | ComponentType<Props>\n      | (Props extends AsIntrinsicElement<infer As> ? As : JSXIntrinsicElementKeys);\n    /**\n     * @internal\n     * The original className prop for the slot, before being modified by the useStyles hook.\n     */\n    [SLOT_CLASS_NAME_PROP_SYMBOL]?: string;\n  };\n\n/**\n * Data type for event handlers. It makes data a discriminated union, where each object requires `event` and `type` property.\n * - `event` is the specific event type\n * - `type` is a string literal. It serves as a clear identifier of the event type that reflects the component's state when the event occurred.\n *    For example, the Tree component's `onNavigation` event handler has different `type` for different key presses: `{ event: React.KeyboardEvent<HTMLElement>; type: typeof ArrowRight } | { event: React.KeyboardEvent<HTMLElement>; type: typeof ArrowLeft }`.\n *    Developers can use the `type` property to identify and filter events of interest.\n * See RFC event-handlers-event-type.md for more details.\n *\n * Example usage:\n * type OnOpenChangeData = (\n *   | EventData\\<'click', React.MouseEvent\\<MyComponentElement\\>\\>\n *   | EventData\\<'keydown', React.KeyboardEvent\\<MyComponentElement\\>\\>\n * ) & \\{ open: boolean; \\};\n */\nexport type EventData<Type extends string, TEvent> =\n  | { type: undefined; event: React.SyntheticEvent | Event }\n  | { type: Type; event: TEvent };\n\n/**\n * Type for props that are event handlers.\n * See RFC event-handlers-event-type.md for more details.\n *\n * Example usage:\n * type OnSomeEventData = EventData\\<'click', React.MouseEvent\\<MyComponentElement\\>\\> & \\{ open: boolean; \\};\n * type SomeProps = \\{ onSomeEvent?: EventHandler\\<OnSomeEventData\\>; \\};\n */\nexport type EventHandler<TData extends EventData<string, unknown>> = (\n  ev: React.SyntheticEvent | Event,\n  data: TData,\n) => void;\n\n/**\n * This type should be used in place of `React.RefAttributes<T>` in all components that specify `ref` prop.\n *\n * If user is using React 18 types `>=18.2.61`, they will run into type issues of incompatible refs, using this type mitigates this issues across react type versions.\n *\n * @remarks\n *\n * React 18 types introduced Type Expansion Change to the `RefAttributes` interface as patch release.\n * These changes were released in `@types/react@18.2.61` (replacing ref with `LegacyRef`, which leaks `string` into the union type, causing breaking changes between v8/v9 libraries):\n *  - {@link https://github.com/DefinitelyTyped/DefinitelyTyped/pull/68720 | PR }\n *  - {@link https://app.unpkg.com/@types/react@18.2.61/files/index.d.ts | shipped definitions }\n *\n *\n * In React 19 types this was \"reverted\" back to the original `Ref<T>` type.\n * In order to maintain compatibility with React 17,18,19, we are forced to use our own version of `RefAttributes`.\n *\n */\nexport interface RefAttributes<T> extends React.Attributes {\n  ref?: React.Ref<T> | undefined;\n}\n"],"names":["React"],"mappings":"AAAA,YAAYA,WAAW,QAAQ"}