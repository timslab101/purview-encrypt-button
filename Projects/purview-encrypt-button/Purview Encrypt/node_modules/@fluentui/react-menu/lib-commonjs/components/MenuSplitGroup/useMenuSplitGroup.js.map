{"version":3,"sources":["../src/components/MenuSplitGroup/useMenuSplitGroup.ts"],"sourcesContent":["'use client';\n\nimport * as React from 'react';\nimport { getIntrinsicElementProps, getRTLSafeKey, useMergedRefs, slot } from '@fluentui/react-utilities';\nimport { useFocusFinders } from '@fluentui/react-tabster';\nimport { useFluent_unstable as useFluent } from '@fluentui/react-shared-contexts';\nimport type { MenuSplitGroupProps, MenuSplitGroupState } from './MenuSplitGroup.types';\nimport { ArrowRight, ArrowLeft } from '@fluentui/keyboard-keys';\nimport { menuSplitGroupMultilineAttr } from './useMenuSplitGroupStyles.styles';\n\n/**\n * Create the state required to render MenuSplitGroup.\n *\n * The returned state can be modified with hooks such as useMenuSplitGroupStyles_unstable,\n * before being passed to renderMenuSplitGroup_unstable.\n *\n * @param props - props from this instance of MenuSplitGroup\n * @param ref - reference to root HTMLElement of MenuSplitGroup\n */\nexport const useMenuSplitGroup_unstable = (\n  props: MenuSplitGroupProps,\n  ref: React.Ref<HTMLElement>,\n): MenuSplitGroupState => {\n  const innerRef = React.useRef<HTMLDivElement>(undefined);\n  const { dir, targetDocument } = useFluent();\n\n  const nextArrowKey = getRTLSafeKey(ArrowRight, dir);\n  const prevArrowKey = getRTLSafeKey(ArrowLeft, dir);\n\n  const { findNextFocusable, findPrevFocusable } = useFocusFinders();\n  const { multilineRef, setMultiline } = useHandleMultilineMenuItem();\n\n  const onKeyDown = React.useCallback(\n    (e: React.KeyboardEvent<HTMLElement>) => {\n      const activeElement = targetDocument?.activeElement;\n      if (!activeElement) {\n        return;\n      }\n\n      if (!innerRef.current?.contains(activeElement)) {\n        return;\n      }\n\n      if (e.key === nextArrowKey) {\n        const next = findNextFocusable(activeElement as HTMLElement, { container: innerRef.current });\n        next?.focus();\n      }\n\n      if (e.key === prevArrowKey) {\n        const prev = findPrevFocusable(activeElement as HTMLElement, { container: innerRef.current });\n        prev?.focus();\n      }\n    },\n    [findNextFocusable, findPrevFocusable, targetDocument, nextArrowKey, prevArrowKey],\n  );\n\n  return {\n    components: {\n      root: 'div',\n    },\n    setMultiline,\n    root: slot.always(\n      getIntrinsicElementProps('div', {\n        role: 'group',\n        // FIXME:\n        // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`\n        // but since it would be a breaking change to fix it, we are casting ref to it's proper type\n        ref: useMergedRefs(ref, innerRef, multilineRef) as React.Ref<HTMLDivElement>,\n        onKeyDown,\n        ...props,\n      }),\n      { elementType: 'div' },\n    ),\n  };\n};\n\n/**\n * Creates a callback that lets a multiline menu item child set an attribute on this component\n * Children can mount before parents so we need to store the value and apply it when the parent is mounted\n */\nconst useHandleMultilineMenuItem = () => {\n  const [handle] = React.useState(() => {\n    let isMultiline = false;\n    let multilineNode: HTMLElement | null = null;\n\n    function applyAttr() {\n      multilineNode?.toggleAttribute(menuSplitGroupMultilineAttr, isMultiline);\n    }\n\n    return {\n      multilineRef: (node: HTMLDivElement | null) => {\n        if (node) {\n          multilineNode = node;\n          applyAttr();\n        } else {\n          multilineNode = null;\n        }\n      },\n      setMultiline: (value: boolean) => {\n        isMultiline = value;\n        applyAttr();\n      },\n    };\n  });\n\n  return handle;\n};\n"],"names":["React","getIntrinsicElementProps","getRTLSafeKey","useMergedRefs","slot","useFocusFinders","useFluent_unstable","useFluent","ArrowRight","ArrowLeft","menuSplitGroupMultilineAttr","useMenuSplitGroup_unstable","props","ref","innerRef","useRef","undefined","dir","targetDocument","nextArrowKey","prevArrowKey","findNextFocusable","findPrevFocusable","multilineRef","setMultiline","useHandleMultilineMenuItem","onKeyDown","useCallback","e","activeElement","current","contains","key","next","container","focus","prev","components","root","always","role","elementType","handle","useState","isMultiline","multilineNode","applyAttr","toggleAttribute","node","value"],"mappings":"AAAA;;;;;+BAmBaW;;;;;;;iEAjBU,QAAQ;gCAC8C,4BAA4B;8BACzE,0BAA0B;qCACV,kCAAkC;8BAE5C,0BAA0B;+CACpB,mCAAmC;AAWxE,mCAAmC,CACxCC,OACAC;IAEA,MAAMC,WAAWd,OAAMe,MAAM,CAAiBC;IAC9C,MAAM,EAAEC,GAAG,EAAEC,cAAc,EAAE,OAAGX,uCAAAA;IAEhC,MAAMY,mBAAejB,6BAAAA,EAAcM,wBAAAA,EAAYS;IAC/C,MAAMG,mBAAelB,6BAAAA,EAAcO,uBAAAA,EAAWQ;IAE9C,MAAM,EAAEI,iBAAiB,EAAEC,iBAAiB,EAAE,OAAGjB,6BAAAA;IACjD,MAAM,EAAEkB,YAAY,EAAEC,YAAY,EAAE,GAAGC;IAEvC,MAAMC,YAAY1B,OAAM2B,WAAW,CACjC,CAACC;YAMMd;QALL,MAAMe,gBAAgBX,mBAAAA,QAAAA,mBAAAA,KAAAA,IAAAA,KAAAA,IAAAA,eAAgBW,aAAa;QACnD,IAAI,CAACA,eAAe;YAClB;QACF;QAEA,IAAI,CAAA,CAAA,CAACf,oBAAAA,SAASgB,OAAAA,AAAO,MAAA,QAAhBhB,sBAAAA,KAAAA,IAAAA,KAAAA,IAAAA,kBAAkBiB,QAAQ,CAACF,cAAAA,GAAgB;YAC9C;QACF;QAEA,IAAID,EAAEI,GAAG,KAAKb,cAAc;YAC1B,MAAMc,OAAOZ,kBAAkBQ,eAA8B;gBAAEK,WAAWpB,SAASgB,OAAO;YAAC;YAC3FG,SAAAA,QAAAA,SAAAA,KAAAA,IAAAA,KAAAA,IAAAA,KAAME,KAAK;QACb;QAEA,IAAIP,EAAEI,GAAG,KAAKZ,cAAc;YAC1B,MAAMgB,OAAOd,kBAAkBO,eAA8B;gBAAEK,WAAWpB,SAASgB,OAAO;YAAC;YAC3FM,SAAAA,QAAAA,SAAAA,KAAAA,IAAAA,KAAAA,IAAAA,KAAMD,KAAK;QACb;IACF,GACA;QAACd;QAAmBC;QAAmBJ;QAAgBC;QAAcC;KAAa;IAGpF,OAAO;QACLiB,YAAY;YACVC,MAAM;QACR;QACAd;QACAc,MAAMlC,oBAAAA,CAAKmC,MAAM,KACftC,wCAAAA,EAAyB,OAAO;YAC9BuC,MAAM;YACN,SAAS;YACT,4EAA4E;YAC5E,4FAA4F;YAC5F3B,SAAKV,6BAAAA,EAAcU,KAAKC,UAAUS;YAClCG;YACA,GAAGd,KAAK;QACV,IACA;YAAE6B,aAAa;QAAM;IAEzB;AACF,EAAE;AAEF;;;CAGC,GACD,MAAMhB,6BAA6B;IACjC,MAAM,CAACiB,OAAO,GAAG1C,OAAM2C,QAAQ,CAAC;QAC9B,IAAIC,cAAc;QAClB,IAAIC,gBAAoC;QAExC,SAASC;YACPD,kBAAAA,QAAAA,kBAAAA,KAAAA,IAAAA,KAAAA,IAAAA,cAAeE,eAAe,CAACrC,0DAAAA,EAA6BkC;QAC9D;QAEA,OAAO;YACLrB,cAAc,CAACyB;gBACb,IAAIA,MAAM;oBACRH,gBAAgBG;oBAChBF;gBACF,OAAO;oBACLD,gBAAgB;gBAClB;YACF;YACArB,cAAc,CAACyB;gBACbL,cAAcK;gBACdH;YACF;QACF;IACF;IAEA,OAAOJ;AACT"}