{"version":3,"file":"getAtomicDebugSequenceTree.cjs.js","sources":["../../../../packages/core/src/devtools/getAtomicDebugSequenceTree.ts"],"sourcesContent":["import { DEFINITION_LOOKUP_TABLE } from '../constants';\nimport type { LookupItem, SequenceHash } from '../types';\nimport { debugData } from './store';\nimport type { DebugSequence } from './types';\nimport { getDebugClassNames } from './utils';\n\nexport function getAtomicDebugSequenceTree(debugSequenceHash: SequenceHash, parentNode?: DebugSequence) {\n  const lookupItem: LookupItem | undefined = DEFINITION_LOOKUP_TABLE[debugSequenceHash];\n  if (lookupItem === undefined) {\n    return undefined;\n  }\n\n  const parentLookupItem = parentNode ? DEFINITION_LOOKUP_TABLE[parentNode.sequenceHash] : undefined;\n  const debugClassNames = getDebugClassNames(\n    lookupItem,\n    parentLookupItem,\n    parentNode?.debugClassNames,\n    parentNode?.children,\n  );\n\n  const node: DebugSequence = {\n    sequenceHash: debugSequenceHash,\n    direction: lookupItem[1],\n    children: [],\n    debugClassNames,\n  };\n\n  const childrenSequences = debugData.getChildrenSequences(node.sequenceHash);\n  childrenSequences\n    .reverse() // first process the overriding children that are merged last\n    .forEach((sequence: SequenceHash) => {\n      const child = getAtomicDebugSequenceTree(sequence, node);\n      if (child) {\n        node.children.push(child);\n      }\n    });\n\n  // if it's leaf (makeStyle node), get css rules\n  if (!node.children.length) {\n    node.rules = {};\n    node.debugClassNames.forEach(({ className }) => {\n      const mapData = debugData.getSequenceDetails(debugSequenceHash);\n      if (mapData) {\n        node.slot = mapData.slotName;\n        node.sourceURL = mapData.sourceURL;\n      }\n\n      const cssRule = debugData.getCSSRules().find(cssRule => {\n        return cssRule.includes(className);\n      });\n\n      node.rules![className] = cssRule!;\n    });\n  }\n\n  return node;\n}\n"],"names":["getAtomicDebugSequenceTree","debugSequenceHash","parentNode","lookupItem","DEFINITION_LOOKUP_TABLE","undefined","parentLookupItem","sequenceHash","debugClassNames","getDebugClassNames","children","node","direction","childrenSequences","debugData","getChildrenSequences","reverse","forEach","sequence","child","push","length","rules","className","mapData","getSequenceDetails","slot","slotName","sourceURL","cssRule","getCSSRules","find","includes"],"mappings":";;;;;;AAMgB,SAAAA,0BAA0BA,CAACC,iBAA+B,EAAEC,UAA0B,EAAA;AACpG,EAAA,MAAMC,UAAU,GAA2BC,iCAAuB,CAACH,iBAAiB,CAAC;EACrF,IAAIE,UAAU,KAAKE,SAAS,EAAE;AAC5B,IAAA,OAAOA,SAAS;AAClB;EAEA,MAAMC,gBAAgB,GAAGJ,UAAU,GAAGE,iCAAuB,CAACF,UAAU,CAACK,YAAY,CAAC,GAAGF,SAAS;AAClG,EAAA,MAAMG,eAAe,GAAGC,wBAAkB,CACxCN,UAAU,EACVG,gBAAgB,EAChBJ,UAAU,KAAA,IAAA,IAAVA,UAAU,KAAA,MAAA,GAAA,MAAA,GAAVA,UAAU,CAAEM,eAAe,EAC3BN,UAAU,KAAV,IAAA,IAAAA,UAAU,uBAAVA,UAAU,CAAEQ,QAAQ,CACrB;AAED,EAAA,MAAMC,IAAI,GAAkB;AAC1BJ,IAAAA,YAAY,EAAEN,iBAAiB;AAC/BW,IAAAA,SAAS,EAAET,UAAU,CAAC,CAAC,CAAC;AACxBO,IAAAA,QAAQ,EAAE,EAAE;AACZF,IAAAA;GACD;EAED,MAAMK,iBAAiB,GAAGC,eAAS,CAACC,oBAAoB,CAACJ,IAAI,CAACJ,YAAY,CAAC;AAC3EM,EAAAA,iBAAiB,CACdG,OAAO,EAAE;GACTC,OAAO,CAAEC,QAAsB,IAAI;AAClC,IAAA,MAAMC,KAAK,GAAGnB,0BAA0B,CAACkB,QAAQ,EAAEP,IAAI,CAAC;AACxD,IAAA,IAAIQ,KAAK,EAAE;AACTR,MAAAA,IAAI,CAACD,QAAQ,CAACU,IAAI,CAACD,KAAK,CAAC;AAC3B;AACF,GAAC,CAAC;AAEJ;AACA,EAAA,IAAI,CAACR,IAAI,CAACD,QAAQ,CAACW,MAAM,EAAE;AACzBV,IAAAA,IAAI,CAACW,KAAK,GAAG,EAAE;AACfX,IAAAA,IAAI,CAACH,eAAe,CAACS,OAAO,CAAC,CAAC;AAAEM,MAAAA;AAAW,KAAA,KAAI;AAC7C,MAAA,MAAMC,OAAO,GAAGV,eAAS,CAACW,kBAAkB,CAACxB,iBAAiB,CAAC;AAC/D,MAAA,IAAIuB,OAAO,EAAE;AACXb,QAAAA,IAAI,CAACe,IAAI,GAAGF,OAAO,CAACG,QAAQ;AAC5BhB,QAAAA,IAAI,CAACiB,SAAS,GAAGJ,OAAO,CAACI,SAAS;AACpC;MAEA,MAAMC,OAAO,GAAGf,eAAS,CAACgB,WAAW,EAAE,CAACC,IAAI,CAACF,OAAO,IAAG;AACrD,QAAA,OAAOA,OAAO,CAACG,QAAQ,CAACT,SAAS,CAAC;AACpC,OAAC,CAAC;AAEFZ,MAAAA,IAAI,CAACW,KAAM,CAACC,SAAS,CAAC,GAAGM,OAAQ;AACnC,KAAC,CAAC;AACJ;AAEA,EAAA,OAAOlB,IAAI;AACb;;;;"}